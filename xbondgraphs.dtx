% \iffalse meta-comment
% 
% Copyright (C) 2018 by M.J.W. Snippe
% -----------------------------------
% 
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
% 
%     http://www.latex-project.org/lppl.txt
% 
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
% 
% This work has the LPPL maintenance status `maintained'.
% 
% The Current Maintainer of this work is M.J.W. Snippe
% 
% This work consists of the files found at https://github.com/MaxSnippe/xbondgraphs.
% 
% \fi
% 
% \iffalse
% 
%<*driver>
\documentclass{ltxdoc}
\input{xbg.preamble.doc.tex}
%
%\OnlyDescription
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
    \DocInput{xbondgraphs.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits \0\1\2\3\4\5\6\7\8\9
%   Exclamation \! Double quote \" Hash (number) \#
%   Dollar \$ Percent \% Ampersand \&
%   Acute accent \' Left paren \( Right paren \)
%   Asterisk \* Plus \+ Comma \,
%   Minus \- Point \. Solidus \/
%   Colon \: Semicolon \; Less than \<
%   Equals \= Greater than \> Question mark \?
%   Commercial at \@ Left bracket \[ Backslash \\
%   Right bracket \] Circumflex \^ Underscore \_
%   Grave accent \` Left brace \{ Vertical bar \|
%   Right brace \} Tilde \~}
%
% \changes{v0.0.1}{2018/05/02}{Initial version}
% 
% \changes{v0.0.2}{2018/05/16}{Changed to \textsf{tcolorbox} documentation style}
% \changes{v0.0.2}{2018/05/16}{Added documentation for various keys}
% 
% \changes{v0.1.0}{2018/05/18}{Added \textsf{iconicdiagrams} library}
% 
% \changes{v0.1.2}{2018/06/05}{Added initial \textsf{blockdiagrams} library}
% \changes{v0.1.2}{2018/06/05}{Removed \textsf{xparse} package dependancy from \textsf{iconicdiagrams} library}
% \changes{v0.1.2}{2018/06/05}{Added \texttt{flip} option for blocks in \textsf{blockdiagram} library}
%
% \GetFileInfo{xbondgraphs.sty}
%
% \DoNotIndex{\#,\$,\%,\&,\@,\\,\{,\},\^,\_,\~,\ ,\if,\else,\fi,\def,\ifcase,\or,\ba,\backgroundpath,\backx,\backy,\centerpoint,\colorlet,\csname,\endcsname,\expandafter,\halfheight,\halfwidth,\hullpointx,\hullpointy,\ifnum,\ifxbg@bond@causality@eout,\ifxbg@bond@causality@fout,\ifxbg@element@multiport,\ifxbg@element@word,\inheritanchor,\inheritanchorborder,\inheritsavedanchors,\ensuremath,\let,\mathbb,\mathbf,\mbw,\muxinputs,\muxoutputs,\NeedsTeXFormat,\newif,\nodeparts,\noexpand,\path,\pgf@sh@lib@mux@in@anchor,\pgf@sh@lib@mux@out@anchor,\pgf@sh@s@mux,\pgf@x,\pgfarrowshullpoint,\pgfarrowssetbackend,\pgfarrowssettipend,\pgfdeclarearrow,\pgfdeclaredecoration,\pgfdeclareshape,\pgfdecoratedangle,\pgfdecoratedinputsegmentlength,\pgfextra,\pgfkeys,\pgfkeysvalueof,\pgflinewidth,\pgfmathcounter,\pgfmathloop,\pgfmathparse,\pgfmathresult,\pgfmathsetlengthmacro,\pgfmathsetlength,\pgfpathlineto,\pgfpathmoveto,\pgfpathrectanglecorners,\pgfpoint,\pgfpointdecoratedinputsegmentlast,\pgfpointorigin,\pgfsetlinewidth,\pgfusepathqstroke,\pgfutil@g@addto@macro,\pgfutil@ifundefined,\ProcessPgfPackageOptions,\ProvidesPackage,\relax,\repeatpgfmathloop,\RequirePackage,\savedanchor,\saveddimen,\savedmacro,\sbw,\small,\startx,\starty,\state,\tikzset,\tipendx,\tipendy,\tipx,\tipy,\usetikzlibrary,\xdef,\xbg@mux@n,\muxmaxio,\iospacing,\PackageWarning,\xbg@bgelabelcolor,\xbg@bondlabelcolor,\xbg@multibondwidth,\xbg@singlebondwidth,\xbg@causalitystrokescale,\xbg@error,\xbg@warning,\pgfqkeys,\pgfkeysalso,\PackageError,\xbgset,\long,\appto,\tikz,\draw,\node,\bge@i,\bge@ii,\bond@i,\bond@ii,\bond,\bge,\pgfkeyscurrentname,\pgfsetfillcolor,\pgfusepathqfill,\input,\usexbglibrary}
%
%\title{The \xbondgraphs package\\[0.5em]\large Drawing bond graphs using \Tikz}
%\author{Marcus J.W. Snippe\\
%   \normalsize\href{mailto:m.j.w.snippe@saxion.nl}{$\langle$\texttt{m.j.w.snippe@saxion.nl}$\rangle$}}
%\date{\filedate\\[0.4em]\normalsize\fileversion}
%
% \input{xbg.document.doc.tex}
%
% \StopEventually{\PrintChanges\listoftodos\printindex}
%
% \clearpage
% \section{Implementation: \xbondgraphs}
%	\tcbset{keyimplementation}
% 	\subsection{Package definition}
%    \begin{macrocode}
%<*xbondgraphs-package>
\NeedsTeXFormat{LaTeX2e}[2017/04/15]
\ProvidesPackage{xbondgraphs}
    [2018/06/05 v0.1.2 Bond graph drawing using TikZ]
%    \end{macrocode}
%   \subsection{Dependencies}
%       This package uses \Tikz to do the actual drawing. \Tikz itself loads the \pgfpkg package that is used for the key management system. The \textsf{amsfonts} package is used for the |\mathbb| font.
%    \begin{macrocode}
\RequirePackage{tikz}
\RequirePackage{amsfonts}
%    \end{macrocode}
%       The |arrows.meta| library is needed to scale the causal stroke arrow tip. The |decorations| library is needed for the |bond| decoration. The |shapes| library is needed for the ellipse shape of word bond graph elements.
%    \begin{macrocode}
\usetikzlibrary{arrows.meta,decorations,shapes}
%    \end{macrocode}
%       \subsection{\pgfpkg keys}
%           First define a few |\ifs| used for boolean \pgfpkg keys.
%    \begin{macrocode}
\newif\ifxbg@bond@causality@eout
\newif\ifxbg@bond@causality@fout
\newif\ifxbg@element@word
\newif\ifxbg@element@multiport
%    \end{macrocode}
%           Some shortcuts to generate package errors and warnings. Errors are not yet used, but might come in handy later.
%    \begin{macrocode}
\def\xbg@error#1#2{\PackageError{xbondgraphs}{#1}{#2}}
\def\xbg@warning#1{\PackageWarning{xbondgraphs}{#1}}
%    \end{macrocode}
%           The main family of \pgfpkg keys is the \docAuxKey*{xbg} family.
%    \begin{macrocode}
\pgfkeys{/xbg/.is family}
%    \end{macrocode}
%           Keys can be set using the \refCom{xbgset} command, analogous to \Tikz's \docAuxCommand*{tikzset} command.
%    \begin{macrocode}
\def\xbgset{\pgfqkeys{/xbg}}
\long\def\xbgset@late@options#1{\appto%
    \xbg@lateoptions@hook{\xbgset{#1}}}
%    \end{macrocode}
%           Package libraries can be loaded using the \refCom{usexbglibrary} command.
%    \begin{macrocode}
\def\usexbglibrary#1{\xbgset{load libraries/.list={#1}}}
%    \end{macrocode}
%           For in-line bond graph elements and bonds the following macros can be used.
%    \begin{macrocode}
\def\bge{\@ifnextchar[%
    {\bge@i}{\bge@i[]}%
}
\def\bge@i[#1]{\@ifnextchar[%
    {\bge@ii{#1}}{\bge@ii{#1}[]}%
}
\def\bge@ii#1[#2]#3{%
    \tikz[baseline={(el.base)}]{
        \node (el) [bge={#3}{#1},inner sep=0pt,#2];
}}
\def\bond{\@ifnextchar[%
    {\bond@i}{\bond@i[]}%
}
\def\bond@i[#1]{\@ifnextchar[%
    {\bond@ii{#1}}{\bond@ii{#1}[]}%
}
\def\bond@ii#1[#2]#3{%
    \tikz[baseline=-0.7ex]{
        \draw[bond={#1},#2] #3;
}}
%    \end{macrocode}
%           The following keys can be set. For complex keys, the working is elaborated in this section.
%    \begin{macrocode}
\xbgset{
    single bond width/.store in=\xbg@singlebondwidth,
    single bond width=0.8pt,
    multi bond width/.store in=\xbg@multibondwidth,
    multi bond width=3.2pt,
    element label color/.code=\colorlet{ElementLabelColor}{#1},
    element label color=blue,
    bond label color/.code=\colorlet{BondLabelColor}{#1},
    bond label color=green!50!black,
    error color/.code=\colorlet{Error}{#1},
    error color=red,
    differential color/.code=\colorlet{Differential}{#1},
    differential color=orange,
    background color/.code={\colorlet{Background}{#1}\def\@xbg@col@Background{#1}},
    background color=white,
    gray/.code=\pgfkeysalso{
        bond label color=gray,
        element label color=gray,
        error color=white!60!black,
        differential color=white!30!black,
    },
    barb direction rule/.is choice,
    barb direction rule/left below/.code={%
        \def\xbg@bond@barbflipang{45}},
    barb direction rule/always below/.code={%
        \def\xbg@bond@barbflipang{-1}},
    barb direction rule/always below,
%    \end{macrocode}
%           The \refKey{/xbg/barb angle} key checks if the angle is between its minimum and maximum value, 15 and 85 degrees respectively, because the tips look distorted if other values are used. The default value of the key is 40 degrees. A value outside these extrema can be given by manually redefining the key macro to a desired value: |\def\xbg@bond@barbangle|\marg{angle}.
%    \begin{macrocode}
    barb angle/.code={
        \ifnum#1>85\relax
            \xbg@warning{The `barb angle' key's value is limited %
                between 15 and 85, so 85 is used}
            \def\xbg@bond@barbangle{85}
        \else
            \ifnum#1<15\relax
                \xbg@warning{The `barb angle' key's value is limited %
                    between 15 and 85, so 15 is used}
                \def\xbg@bond@barbangle{15}
            \else
                \def\xbg@bond@barbangle{#1}
            \fi
        \fi
    },
    barb angle=40,
%    \end{macrocode}
%           The causality of the bond can be set with the following four keys, of which \refKey{/xbg/effort in} and \refKey{/xbg/flow out} are aliases which set the causality stroke at the end of the bond, and \refKey{/xbg/effort out} and \refKey{/xbg/flow in} set the causality stroke to the beginning of the bond. These options set the \docAuxKey[xbg]{eout} and \docAuxKey[xbg]{fout} keys accordingly. Initially the latter are both false, so no causal stroke is drawn.
%    \begin{macrocode}
    effort out/.code=\xbgset{
        eout=true,
        fout=false,
        causal stroke/.append style={#1},
    },
    flow out/.code=\xbgset{
        eout=false,
        fout=true,
        causal stroke/.append style={#1},
    },
    unset causality/.code=\xbgset{
        eout=false,
        fout=false,
    },
    effort in/.forward to=/xbg/flow out,
    flow in/.forward to=/xbg/effort out,
    eout/.is if=xbg@bond@causality@eout,
    eout/.default=true,
    eout/.initial=false,
    fout/.is if=xbg@bond@causality@fout,
    fout/.default=true,
    fout/.initial=false,
%    \end{macrocode}
%           The \refKey{/xbg/multi} key sets some additional keys, changes the arrow tip type, and sets the line width accordingly (although |draw = none| in the bond template style, the placing of edge nodes needs the correct line width).
%    \begin{macrocode}
    multi/.code={
        \xbgset{
            causality stroke scale=3,
            barb arrow head=Multi Bond Barb,
            bond template/.append style={
                double=Background,
                double distance={\xbg@multibondwidth%
                    -2*\xbg@singlebondwidth}
            },
        }
        \tikzset{
            line width = \xbg@multibondwidth,
        }
    },
    causality stroke scale/.store in=\xbg@causalitystrokescale,
    causality stroke scale=2,
    barb arrow head/.is choice,
    barb arrow head/Single Bond Barb/.code={
        \def\xbg@bond@barbtip{Single Bond Barb}
    },
    barb arrow head/Multi Bond Barb/.code={
        \def\xbg@bond@barbtip{Multi Bond Barb}
    },
    barb arrow head=Single Bond Barb,
    bond template/.style={
        draw,
        shorten <=3pt,
        shorten >=3pt,
        line width=\xbg@singlebondwidth,
    },
    bond label/.code=\tikzset{
        text=BondLabelColor,
        font=\small,
        sloped,
    },
    causal stroke/.style={
        width=\xbg@causalitystrokescale*\xbg@multibondwidth,
    },
%    \end{macrocode}
%           The following keys are used for bond graph elements.
%    \begin{macrocode}
    multiport/.is if=xbg@element@multiport,
    multiport/.default=true,
    multiport/.initial=false,
    n/.store in=\xbg@element@n,
    n=1,
    word/.is if=xbg@element@word,
    word/.default=true,
    word/.initial=false,
    element label/.style={
        label distance=2pt,
        ElementLabelColor,
    },
    element pin/.style={
        /xbg/element label,
        pin distance = 2pt,
        pin edge={
            edge node={node[sloped,inner sep=0pt,%
                ElementLabelColor,pos=1]{:}},
            draw=none,
        },
    },
%    \end{macrocode}
%           The \docAuxKey[xbg]{bge template} key is used in nodes which are given the \refKey{/tikz/bond graph element} key. Because it uses the \docAuxKey*{/tikz/node contents} key, there are some shortcomings on nodes using the \refKey{/tikz/bond graph element} style. The \docAuxKey*{/tikz/node contents} key is described on page 215 of the \href{http://ctan.cs.uu.nl/graphics/pgf/base/doc/pgfmanual.pdf}{\pgfpkg manual} (version 3.0.1a).
%    \begin{macrocode}
    bge template/.code={
        \tikzset{
            inner sep = 1.5pt,
            node contents={%
                \ifxbg@element@multiport%
                    \ifnum\xbg@element@n=1%
                        \ensuremath{\mathbb{#1}}%
                    \else%
                        \ensuremath{\mathbb{#1}_{\xbg@element@n}}%
                    \fi%
                \else%
                    \ifnum\xbg@element@n=1%
                        \ensuremath{\mathbf{#1}}%
                    \else%
                        \ensuremath{\mathbf{#1}_{\xbg@element@n}}%
                    \fi%
                \fi%
            },
            append after command={
                \pgfextra{
                    \tikzset{
                        every pin/.style={
                            /xbg/element pin,
                        },
                        every label/.style={
                            /xbg/element label,
                        },
                    },
                }
            },
        }
        \ifxbg@element@word
            \tikzset{
                draw,
                shape=ellipse,
                line width = \xbg@singlebondwidth,
            }
        \fi
    },
%    \end{macrocode}
%           The \refKey{/xbg/label colon} redefines the \docAuxKey*{/tikz/label} key to forward its argument to the \docAuxKey*{/tikz/pin} key, such that a colon can be drawn between the element and its label.
%    \begin{macrocode}
    label colon/.code=\tikzset{
        label/.code={},
        label/.forward to=/tikz/pin,
    },
%    \end{macrocode}
%           The following keys are used for (de)mux elements. These are not considered bond graph elements, because they can also be used in block diagrams. To give mux labels the same color, use the \docColor{ElementLabelColor}, or use the \docAuxKey[xbg]{element label} style.
%    \begin{macrocode}
    mux inputs/.code={
        \pgfmathparse{int(#1)}
        \let\xbg@mux@inputs=\pgfmathresult
    },
    mux inputs=1,
    mux outputs/.code={
        \pgfmathparse{int(#1)}
        \let\xbg@mux@outputs=\pgfmathresult
    },
    mux outputs=1,
    mux io spacing/.store in=\xbg@mux@iospacing,
    mux io spacing=5mm,
    mux template/.code=\tikzset{
        outer sep = 0pt,
        inner sep = 0pt,
        minimum width = 2.5pt,
        minimum height = \xbg@mux@height,
        node contents = {},
        fill=black,
        shape=mux,
    },
    load libraries/.code={
        \xbgset{library/#1}
    },
    library/iconicdiagrams/.code={\input{xbg.iconicdiagrams.code.tex}},
    library/blockdiagrams/.code={\input{xbg.blockdiagrams.code.tex}},
    library/all/.code=\xbgset{load libraries/.list={iconicdiagrams,blockdiagrams}},
    library/.unknown/.code={\xbg@error{No library named "\pgfkeyscurrentname" exists}{}},
}
%    \end{macrocode}
%       \subsection{\Tikz styles}
%           To make styles directly accesible inside |\node|\oarg{options} and |\draw|\oarg{options}, the styles are defined inside the \docAuxKey*{/tikz} family.
%    \begin{macrocode}
\tikzset{
    bond/.code={
        \xbgset{#1}
        \tikzset{
            draw=none,
            decoration={bond},
            postaction=decorate
        }
    },
    bond graph element/.code 2 args={
        \xbgset{#2,bge template={#1}}
    },
    bge/.forward to=/tikz/bond graph element,
    flow/.style={
        edge node={node[/xbg/bond label,below]{#1}},
    },
    effort/.style={
        edge node={node[/xbg/bond label,above]{#1}},
    },
%    \end{macrocode}
%           The \refKey{/tikz/mux} style uses the number of in- and outputs to determine the minimum height of the node. This is used in the shape to place the anchors at the right position.
%    \begin{macrocode}
    mux/.code={
        \xbgset{#1}
        \pgfmathsetlengthmacro{\xbg@mux@height}{%
            int(max(\xbg@mux@inputs,\xbg@mux@outputs))%
            *\xbg@mux@iospacing}
        \xbgset{mux template}
    },
}
%    \end{macrocode}
%       \subsection{Shape(s)}
%           For now the only defined shape is the \refShp{mux} shape.
%    \begin{macrocode}
\pgfdeclareshape{mux}{
    \nodeparts{}
    \savedanchor\centerpoint{\pgfpointorigin}
    \inheritsavedanchors[from=rectangle]
    \inheritanchorborder[from=rectangle]
    \inheritanchor[from=rectangle]{north}
    \inheritanchor[from=rectangle]{north west}
    \inheritanchor[from=rectangle]{north east}
    \inheritanchor[from=rectangle]{center}
    \inheritanchor[from=rectangle]{west}
    \inheritanchor[from=rectangle]{east}
    \inheritanchor[from=rectangle]{south}
    \inheritanchor[from=rectangle]{south west}
    \inheritanchor[from=rectangle]{south east}
    \savedmacro\muxinputs{%
        \pgfmathparse{int(\xbg@mux@inputs)}%
        \let\muxinputs=\pgfmathresult}%
    \savedmacro\muxoutputs{%
        \pgfmathparse{int(\xbg@mux@outputs)}%
        \let\muxoutputs=\pgfmathresult}%
    \savedmacro\muxmaxio{%
        \pgfmathparse{int(max(\xbg@mux@inputs,\xbg@mux@outputs))}%
        \let\muxmaxio=\pgfmathresult}%
    \saveddimen\halfwidth{\pgfmathsetlength\pgf@x{%
        \pgfkeysvalueof{/pgf/minimum width}/2}\pgfmathresult}
    \saveddimen\halfheight{\pgfmathsetlength\pgf@x{%
        \pgfkeysvalueof{/pgf/minimum height}/2}\pgfmathresult}
    \saveddimen\iospacing{\pgfmathsetlength\pgf@x{%
        \xbg@mux@iospacing}\pgfmathresult}
    \backgroundpath{
        \pgfpathrectanglecorners{
            \pgfpoint{-\halfwidth}{-\halfheight}
        }{
            \pgfpoint{\halfwidth}{\halfheight}
        }
    }
%    \end{macrocode}
%           The \docAuxCommand*{pgfutil@g@addto@macro}\docAuxCommand*{pgf@sh@s@mux} line enables us to add some code to every instance of the |mux| shape. It will iteratively add anchors for the in- and outputs, until their respective maximum is reached.
%    \begin{macrocode}
    \pgfutil@g@addto@macro\pgf@sh@s@mux{%
        \pgfmathloop%
        \ifnum\pgfmathcounter>\muxinputs\relax%
        \else%
            \pgfutil@ifundefined{pgf@anchor@mux@input \pgfmathcounter}{%
                \expandafter\xdef\csname pgf@anchor@mux@input %
                    \pgfmathcounter\endcsname{\noexpand%
                    \pgf@sh@lib@mux@in@anchor{\pgfmathcounter}%
                }%
            }{}
        \repeatpgfmathloop%
        \pgfmathloop%
        \ifnum\pgfmathcounter>\muxoutputs\relax%
        \else%
            \pgfutil@ifundefined{pgf@anchor@mux@output \pgfmathcounter}{%
                \expandafter\xdef\csname pgf@anchor@mux@output %
                \pgfmathcounter\endcsname{\noexpand%
                    \pgf@sh@lib@mux@out@anchor{\pgfmathcounter}%
                }%
            }{}
        \repeatpgfmathloop%
    }%
}
%    \end{macrocode}
%           The following macros are called to add a point for the anchors. They make sure that spacing is equal, and that the in- and outputs are centered around the vertical middle of the \refShp{mux} element.
%    \begin{macrocode}
\def\pgf@sh@lib@mux@in@anchor#1{%
    \pgfpoint{-\halfwidth}{\halfheight-0.5*\iospacing*(%
        \muxmaxio-\muxinputs-1)-\iospacing*#1}%
}
\def\pgf@sh@lib@mux@out@anchor#1{%
    \pgfpoint{\halfwidth}{\halfheight-0.5*\iospacing*(%
        \muxmaxio-\muxoutputs-1)-\iospacing*#1}%
}
%    \end{macrocode}
%       \subsection{Arrow tips}
%           \label{imp:arrowtips}
%           The arrow tips defined by the \xbondgraphs package are \refArr{Single Bond Barb} and \refArr{Multi Bond Barb}.
%    \begin{macrocode}
\pgfdeclarearrow{
    name={Single Bond Barb},
    setup code={
%    \end{macrocode}
%           First locally define the line width of a single bond, a multibond, and the angle the barb makes with the bond. 
%    \begin{macrocode}
        \pgfmathsetlengthmacro{\sbw}{\pgflinewidth}
        \pgfmathsetlengthmacro{\mbw}{\xbg@multibondwidth}
        \pgfmathsetlengthmacro{\ba}{\xbg@bond@barbangle}
%    \end{macrocode}
%           Calculate the $ x $- and $ y $ position of the points that the barb will follow. If one was walking along the bond from startpoint to endpoint, the origin of this scope would be the endpoint, the $ x $ direction would be forward, and the $ y $ direction would be leftward.
%    \begin{macrocode}
        \pgfmathsetlengthmacro{\tipx}{\sbw}
        \pgfmathsetlengthmacro{\tipy}{0pt}
        \pgfmathsetlengthmacro{\backx}{-1/tan(\ba)*%
            (\mbw-0.5*cos(\ba)*\sbw) + \sbw}
        \pgfmathsetlengthmacro{\backy}{\mbw - 0.5*cos(\ba)*\sbw}
%    \end{macrocode}
%           \pgfpkg needs the outer points of the arrow tip to accurately determine the bounding box. Also, the actual tip of the arrow is needed, so the drawn bond will end exactly at the endpoint (the bond \Tikz styles use a |shorten > = |\meta{dimen} and |shorten > = |\meta{dimen} so they will not end exactly at the endpoint, but still this is important so the right dimension is subtracted from the path).
%    \begin{macrocode}
        \pgfmathsetlengthmacro{\hullpointx}{\backx + 0.5*\sbw*sin(\ba)}
        \pgfmathsetlengthmacro{\hullpointy}{\mbw}
        \pgfmathsetlengthmacro{\tipendx}{0.5*\sbw/tan(\ba/2) + \tipx}
        \pgfmathsetlengthmacro{\tipendy}{-0.5*\sbw}
%    \end{macrocode}
%           These commands are used to set the outer dimensions that \Tikz/\pgfpkg needs.
%    \begin{macrocode}
        \pgfarrowssettipend{\tipendx}
        \pgfarrowssetbackend{\backx}
        \pgfarrowshullpoint{\hullpointx}{\hullpointy}
        \pgfarrowshullpoint{\tipendx}{\tipendy}
    },
%    \end{macrocode}
%           \pgfpkg will need to know which macros influence the appearance of the arrow tip. This way it can reuse code if the parameters don't change.
%    \begin{macrocode}
    parameters={
        \xbg@bond@barbangle,
        \xbg@singlebondwidth,
        \xbg@multibondwidth
    },
%    \end{macrocode}
%           The actual drawing of the arrow is simply following the points determined earlier.
%    \begin{macrocode}
    drawing code={
        \pgfpathmoveto{\pgfpointorigin}
        \pgfpathlineto{\pgfpoint{\tipx}{\tipy}}
        \pgfpathlineto{\pgfpoint{\backx}{\backy}}
        \pgfusepathqstroke
    },
}
%    \end{macrocode}
%           Repeat all for the \refArr{Multi Bond Barb}. Additionally, the \refArr{Multi Bond Barb} fills the arrow tip with the \docColor{Background} color. To know if this color has changed, an additional macro is used and passed to the arrow definition as parameter.
%    \begin{macrocode}
\pgfdeclarearrow{
    name={Multi Bond Barb},
    setup code={
        \pgfmathsetlengthmacro{\sbw}{\xbg@singlebondwidth}
        \pgfmathsetlengthmacro{\mbw}{\pgflinewidth}
        \pgfmathsetlengthmacro{\ba}{\xbg@bond@barbangle}
        \pgfmathsetlengthmacro{\startx}{0pt}
        \pgfmathsetlengthmacro{\starty}{-0.5*\mbw+0.5*\sbw}
        \pgfmathsetlengthmacro{\tipx}{(\mbw-\sbw)/tan(\ba)}
        \pgfmathsetlengthmacro{\tipy}{-0.5*\mbw + 0.5*\sbw}
        \pgfmathsetlengthmacro{\backy}{1.5*\mbw - 0.5*\sbw*cos(\ba)}
        \pgfmathsetlengthmacro{\backx}{-(\backy+\tipy)/tan(\ba)}
        \pgfmathsetlengthmacro{\hullpointx}{\backx + 0.5*\sbw*sin(\ba)}
        \pgfmathsetlengthmacro{\hullpointy}{1.5*\mbw}
        \pgfmathsetlengthmacro{\tipendx}{0.5*\sbw/tan(\ba/2) + \tipx}
        \pgfmathsetlengthmacro{\tipendy}{-0.5*\mbw}
        \pgfarrowssettipend{\tipendx}
        \pgfarrowssetbackend{\backx}
        \pgfarrowshullpoint{\hullpointx}{\hullpointy}
        \pgfarrowshullpoint{\tipendx}{\tipendy}
    },
    parameters={
        \xbg@bond@barbangle,
        \xbg@singlebondwidth,
        \xbg@multibondwidth,
        \@xbg@col@Background,
    },
    drawing code={
        \pgfpathmoveto{\pgfpoint{\startx}{\starty}}
        \pgfpathlineto{\pgfpoint{\tipx}{\tipy}}
        \pgfpathlineto{\pgfpoint{\startx}{-\starty}}
        \pgfpathlineto{\pgfpoint{\startx}{\starty}}
        \pgfsetfillcolor{Background}
        \pgfusepathqfill
        \pgfpathmoveto{\pgfpoint{\startx}{\starty}}
        \pgfpathlineto{\pgfpoint{\tipx}{\tipy}}
        \pgfpathlineto{\pgfpoint{\backx}{\backy}}
        \pgfsetlinewidth{\sbw}
        \pgfusepathqstroke
    }
}
%    \end{macrocode}
%       \subsection{Decoration(s)}
%           The \refDec{bond} decoration is the only decoration defined by the \xbondgraphs package. This decoration is used to determine the direction of the barb. It starts with an |initial| state, which only draws a line from the current point to the next segment end. The width expected by \pgfpkg for this decoration is an arbitrary length longer than the segment length, such that only one state per segment is used.
%    \begin{macrocode}
\pgfdeclaredecoration{bond}{initial}{
    \state{initial}[width=\pgfdecoratedinputsegmentlength+1pt]{
        \pgfpathlineto{\pgfpointdecoratedinputsegmentlast}
    }
    \state{final}{
%    \end{macrocode}
%           With this \docAuxCommand*{ifcase} the direction of the arrow tip is determined, and stored in \docAuxCommand*{xbg@bond@barbdir}. This code is partly taken from the \bondgraphs package, so credits go to Geert Folkertsma, and Mark Wibrow for his answer at \href{https://tex.stackexchange.com/a/208393/74459}{tex.stackexchange.com}.
%
%           The value of the macro \docAuxCommand*{xbg@bond@barbflipang} is set to either -1, or 90, with the \refKey{/xbg/barb direction rule} key.
%    \begin{macrocode}
        \pgfmathparse{int((\pgfdecoratedangle+%
            \xbg@bond@barbflipang)/90)}
        \ifcase\pgfmathresult
            \def\xbg@bond@barbdir{right}
        \or
            \def\xbg@bond@barbdir{left}
        \or
            \def\xbg@bond@barbdir{left}
        \else
            \def\xbg@bond@barbdir{right}
        \fi
%    \end{macrocode}
%           If the causality of the bond is determined, it is either effort out or flow out. The corresponding arrow definition is set here. If no causality is determined, the arrow definition is either the \refArr{Single Bond Barb} or the \refArr{Multi Bond Barb}, depending if the \refKey{/xbg/multi} key of the bond has been set.
%
%           The causal stroke is drawn as a \textbar-arrow tip, using the \docAuxKey[xbg]{causal stroke} style.
%    \begin{macrocode}
        \ifxbg@bond@causality@eout
            \tikzset{-{\xbg@bond@barbtip[\xbg@bond@barbdir]%
                .|[/xbg/causal stroke]}}
        \else
            \ifxbg@bond@causality@fout
                \tikzset{{|[/xbg/causal stroke]}-{\xbg@bond@barbtip%
                    [\xbg@bond@barbdir]}}
            \else
                \tikzset{-{\xbg@bond@barbtip[\xbg@bond@barbdir]}}
            \fi
        \fi
        \path[/xbg/bond template]\pgfextra{\pgfpathlineto{%
            \pgfpointdecoratedinputsegmentlast}};
    }
}
%</xbondgraphs-package>
%    \end{macrocode}
%       \iffalse
%       \section{Implementation: \xbondgraphs-iconic library}
%    \begin{macrocode}
%<*xbg-iconicdiagrams-code>
\makeatletter
\usetikzlibrary{decorations.pathreplacing,decorations.pathmorphing,patterns}

\xbgset{,
    iconic label color/.code=\colorlet{Iconic Label}{#1},
    iconic label color=blue,
    iconic contents color/.code=\colorlet{Iconic Contents}{#1},
    iconic contents color=blue,
}
%    \end{macrocode}
%           \subsection{Signals}
%    \begin{macrocode}
\tikzset{
	signal/.style args = {#1}{
		-{Latex[length=6pt,width=6pt]},
		thick,
		#1,
	},
	signal/.default = {},
	msignal/.style args = {#1}{
		double,
		double distance = 2.5pt,
		-{Latex[length=7pt,width=7pt]},
		thick,
		#1,
	},
	msignal/.default = {},
}
%    \end{macrocode}
%           \subsection{Block diagrams}
%    \begin{macrocode}
\tikzset{
	iconic block/.style args ={
		draw,
		thick,
		minimum height = 1cm,
		minimum width = 1cm,
	},
	iconic block/.default = {},
}

\tikzset{
	sinewavegen/.style args = {#1}{
		iconic block,
		path picture = {
			\begin{scope}[x=1mm,y=2.5mm]
				\draw (-4mm,3.5mm) -- (-4mm,-3.5mm);
				\draw (-4.5mm,0mm) -- (4.5mm,0mm);
				\draw[Iconic Contents,thick] (-4mm,0) sin ++(1,1) cos ++(1,-1) sin ++(1,-1) cos ++(1,1) sin ++(1,1) cos ++(1,-1) sin ++(1,-1) cos ++(1,1);
			\end{scope}
		}
	},
	motionprofilegen/.style args = {#1}{
		iconic block,
		path picture = {
			\draw (-4mm,3.5mm) -- (-4mm,-3.5mm);
			\draw (-4.5mm,-3mm) -- (4.5mm,-3mm);
			\begin{scope}[Iconic Contents,thick,smooth,variable=\t,x=1cm,y=1cm]
				\pgfmathsetmacro{\hm}{0.5}
				\pgfmathsetmacro{\tm}{0.7}
				\pgfmathsetmacro{\ts}{-0.4}
				\pgfmathsetmacro{\ofs}{-0.3}
				\draw[domain=\ts:\ts+\tm/4] plot ({\t},{\ofs + 16/3*\hm*((\t-\ts)/\tm)^3});
				\draw[domain=\ts+\tm/4:\ts+3*\tm/4] plot ({\t},{\ofs + 32*\hm/(\tm)^3*(\tm*(\t-\ts)^2/4 - (\t-\ts)^3/6 - (\tm)^2*(\t-\ts)/16 + (\tm)^3/192)});
				\draw[domain= \ts+3*\tm/4:\ts+\tm]  plot ({\t},{\ofs + 32*\hm/(\tm)^3*(-\tm*(\t-\ts)^2/2+(\t-\ts)^3/6+(\tm)^2*(\t-\ts)/2-13*(\tm)^3/96)});
				\draw[domain=\ts+\tm:\ts+\tm+0.1] plot ({\t},{\ofs+\hm});
			\end{scope}
		}
	}
}

\tikzset{
	integrator/.style args = {#1}{
		iconic block,
		path picture = {
			\node[Iconic Contents]{\ensuremath{\int}};
		}
	}
}
%    \end{macrocode}
%           \subsection{Iconic diagrams}
%    \begin{macrocode}
\tikzset{
	component/.style={
		inner sep = 0pt,
		prefix after command= {
			\pgfextra{
				\tikzset{
					every label/.style={
						text=Iconic Label,
						label distance = 0pt,
					}
				}
			}
		},
	},
	node component/.style={
		component
	},
	line component/.style={
		component,
		sloped,
		allow upside down,
		pos = .5,
	},
	hydrline/.style={
		draw,
		line width = 1pt,
		double,
		double distance between line centers=3mm,
	},
	flowsource/.style 2 args={
		component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={#2:#1},
		path picture={%
			\draw[hydrline] (-.5,0)--(.5,0);
			\draw[fill=Background] (0,.15) circle (.15);
			\draw[fill=Background] (0,-.15) circle (.15);
		}
	},
	flowresistance/.style 2 args={
		component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={#2:#1},
		path picture={%
			\draw[hydrline] (-.5,0)--(.5,0);
			\draw (1/3+.1,.1) -- (1/3-.1,-.1)
			(1/3-.1,+.1) -- (1/3+.1,-.1);
			\draw (-1/3+.1,.1) -- (-1/3-.1,-.1)
			(-1/3-.1,+.1) -- (-1/3+.1,-.1);
			\draw (.1,.1) -- (-.1,-.1)
			(-.1,+.1) -- (.1,-.1);
		}
	},
	hydrinertia/.style 2 args={
		component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={#2:#1},
		path picture={%
			\draw[hydrline] (-.5,0)--(.5,0);
			\fill[Background!80!black] (-.4,-.1) rectangle (.4,.1);
		}
	},
	battery/.style={
		line component,
		minimum height = 1cm, 
		minimum width = 6mm+4\pgflinewidth,
		path picture={%
			\fill[Background] (-3mm,-0.6*\pgflinewidth) rectangle (3mm,0.6*\pgflinewidth);
			\draw (3mm,-5mm) -- ++(0,10mm);
			\draw (-3mm/3,-5mm) -- ++(0,10mm);
			\pgfmathparse{min(2.5*\pgflinewidth,5pt)}
			\begin{scope}[line width = \pgfmathresult pt]
				\draw (3mm/3,-2.5mm) -- ++(0,5mm);
				\draw (-3mm,-2.5mm) -- ++(0,5mm);
			\end{scope}
		},
	},
	voltage source/.style={
		line component,
		minimum height = 1cm, 
		minimum width=1cm,
		path picture={%
			\fill[Background] (-0.4,-0.6*\pgflinewidth) rectangle (0.4,0.6*\pgflinewidth);
			\draw (0,0) circle (.4);
			\draw (-.4,0) -- (.4,0);
			\node[path picture={
				\draw(0,-.75mm) -- (0,.75mm);
				\draw(-.75mm,0) -- (.75mm,0);
			}] at (.4,.4){};
			\node[path picture={
				\draw(-.75mm,0) -- (.75mm,0);
			}] at (-.4,.4){};
		},
	},
	currentsensor/.style args={#1}{
		line component,
		minimum height = 1cm, 
		minimum width=1cm,
		path picture={%
			\draw[fill=Background] (0,0) circle (.4);
			\node {A};
			%			\node at (.4,.4){\tikz[line width=1pt]{\draw(0,-.75mm) -- (0,.75mm);\draw(-.75mm,0) -- (.75mm,0);}};
			%			\node at (-.4,.4){\tikz[line width=1pt]{\draw(-.75mm,0) -- (.75mm,0);}};
		},
		#1,
	},
	current/.style args={#1}{
		line component,
		minimum height = 2mm,
		minimum width = 2mm,
		path picture = {
			\fill (-1mm,1mm) -- (1mm,0) -- (-1mm,-1mm) -- cycle;
		},
		#1,
	},
	voltagesensor/.style args={#1}{
		line component,
		minimum height = 1cm, 
		minimum width=1cm,
		path picture={%
			\draw[fill=Background] (0,0) circle (.4);
			\node {V};
			%			\node at (.4,.4){\tikz[line width=1pt]{\draw(0,-.75mm) -- (0,.75mm);\draw(-.75mm,0) -- (.75mm,0);}};
			%			\node at (-.4,.4){\tikz[line width=1pt]{\draw(-.75mm,0) -- (.75mm,0);}};
		},
		#1,
	},
	oscilloscope/.style args={#1}{
		node component,
		minimum height = 1cm, 
		minimum width=1cm,
		path picture={%
			\draw[fill=Background] (0,0) circle (.4);
			\draw (-.25,-.1) -- (0,.1) -- (0,-.1) -- (.25,.1) -- (.25,-.1);
		},
		#1,
	},
	functiongenerator/.style args={#1}{
		node component,
		minimum height = 1cm, 
		minimum width=1cm,
		path picture={%
			\draw[fill=Background] (0,0) circle (.4);
			\draw[line width = 1pt] (-0.3,0) arc (180:0:.15) arc (-180:0:.15);
		},
		#1,
	},
	gyrator/.style={
		component,
		minimum height=10mm+\pgflinewidth, 
		minimum width=8mm+\pgflinewidth,
		path picture={%
			\draw[fill=Background] (-.2,-.5) rectangle (.2,.5);
			\draw[fill=Background] (0,0) circle (.4);
		}
	},
	resistor/.style={
		line component,
		minimum height=4mm+\pgflinewidth,
		minimum width=1cm+\pgflinewidth,
		path picture={%
			\fill[Background] (-0.5,-0.6*\pgflinewidth) rectangle (0.5,0.6*\pgflinewidth);
			\draw (-.5,-.2) rectangle (.5,.2);
		},
	},
	resistor2/.style={
		line component,
		minimum height = 4mm,
		minimum width = 1.5cm,
		path picture = {
			\fill[Background] (-0.5,-0.6*\pgflinewidth) rectangle (0.5,0.6*\pgflinewidth);
			\draw[decoration={
				aspect=.4,
				segment length=2mm,
				amplitude=1.5mm,
				zigzag,
				pre length=1mm,
				post length=1mm,
			},decorate] (-.5,0) -- (.5,0);
		},
	},
	inductor/.style={
		line component,
		minimum height=4mm,
		minimum width=10mm,
		path picture={%
			\fill[Background] (-0.5,-0.6*\pgflinewidth) rectangle (0.5,0.6*\pgflinewidth);
			\draw (-5mm,0) -- (-4mm,0) arc (180:0:1mm) -- ++(0,-0.5*\pgflinewidth)
				(-2mm,0) arc (180:0:1mm) -- ++(0,-0.5*\pgflinewidth)
				(0,0) arc (180:0:1mm) -- ++(0,-0.5*\pgflinewidth)
				( 2mm,0) arc (180:0:1mm) -- (5mm,0);
		},
	},
	inductor2/.style args={#1}{
		line width = 0.4pt,
		sloped,
		allow upside down,
		pos = .5,
		minimum height=1cm,
		minimum width=1.5cm,
		path picture={%
			\pgfmathsetmacro{\extraangle}{40}
			\pgfmathsetmacro{\radius}{.8/(2+6*cos(\extraangle))}
			\fill[Background] (-5mm+.5pt,-.1) rectangle (5mm-.5pt,.1);
			\draw (-5mm,0)-- (-4mm,0)
			arc (180:-\extraangle:\radius)
			arc (180+\extraangle:-\extraangle:\radius)
			arc (180+\extraangle:-\extraangle:\radius)
			arc (180+\extraangle:0:\radius)
			-- (5mm,0);
		},
		#1
	},
	capacitor/.style={
		line component,
		minimum height = 0.8cm,
		minimum width = 0.5cm,
		path picture={%
			\pgfmathparse{max(1.5*\pgflinewidth,2pt)}
			\pgfmathsetlengthmacro{\halfwidth}{\pgfmathresult pt}
			\fill[Background] (-\halfwidth,-0.6*\pgflinewidth) rectangle (\halfwidth,0.6*\pgflinewidth);
			\draw (-\halfwidth,-0.3) -- ++(0,0.6);
			\draw (\halfwidth,-0.3) -- ++(0,0.6);
		},
	},
	switch/.style args={#1}{
		line component,
		minimum height = 7mm,
		minimum width = 15mm,
		path picture={%
			\draw[Background,line width=3pt] (-.4,0) -- (.4,0);
			\fill (-.4,0) circle (.5mm);
			\fill (.4,0) circle (.5mm);
			\draw (-.4,0) -- ++(25:.8);
		},
		#1
	},
	electric earth/.style={
		component,
		minimum height = 1cm,
		minimum width=1.5cm,
		path picture={%
			\draw (0,0) --++(0,-.1)
			(-.3,-.1) -- (.3,-.1)
			(-.2,-.2) -- (.2,-.2)
			(-.1,-.3) -- (.1,-.3);
		}
	},
	mechanical earth/.style args={#1}{
		node component,
		minimum width = .5cm,
		path picture={%
			\fill[pattern = north east lines] (path picture bounding box.north west) rectangle (path picture bounding box.south);
			\draw(path picture bounding box.north) -- (path picture bounding box.south);
		},
		#1
	},
	spring/.style args={#1}{
		line component,
		minimum height = 0.5cm,
		minimum width=1.5cm,
		path picture={%
			\fill[Background] (-0.5,-0.6*\pgflinewidth) rectangle (0.5,0.6*\pgflinewidth);
			\draw(-0.5,0) -- (-0.4,0) decorate[decoration={aspect=.5,segment length=1mm,amplitude=1mm,coil}]{ -- (0.4,0)} -- (0.5,0);
		},
		#1
	},
	spring2/.style args={#1}{
		resistor2={#1},
		%		line component,
		%		minimum height = 1cm,
		%		minimum width=1.5cm,
		%		label={[label distance = 0cm]#2:#1},
		%		path picture={%
		%			\fill[Background] (-.5cm+.5pt,-.1) rectangle (.5cm-.5pt,.1);
		%			\draw[decoration={segment length=3.2mm,amplitude=2mm,zigzag,pre length = .2mm, post length = .2mm},decorate] (-.5,0) -- (.5,0);
		%		}
	},
	damper/.style={
		line component,
		minimum height = 0.5cm,
		minimum width=4mm,
		path picture={%
			\pgfmathparse{max(4pt,2.5*\pgflinewidth)}
			\pgfmathsetlengthmacro{\iconix@damper@width}{\pgfmathresult pt}
			\fill[Background] (-0.5*\iconix@damper@width,-0.6*\pgflinewidth) rectangle (0,0.6*\pgflinewidth);
			\draw (0.5*\iconix@damper@width,-0.2) -- (-0.5*\iconix@damper@width,-0.2) -- (-0.5*\iconix@damper@width,0.2) -- (0.5*\iconix@damper@width,0.2);
			\draw (0,0.125) -- (0,-0.125);
		},
	},
	friction/.style 2 args={
		line component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={[label distance = 0cm]#2:#1},
		path picture={%
			\fill[pattern = north east lines] (-.5,1/3) rectangle (.5,1/2);
			\fill[pattern = north east lines] (-.5,-1/3) rectangle (.5,-1/2);
			\draw (-.5,1/3) -- (.5,1/3);
			\draw (-.5,-1/3) -- (.5,-1/3);
			\draw (-1/3+.1,1/6+.1) -- (-1/3-.1,1/6-.1)
			(-1/3-.1,1/6+.1) -- (-1/3+.1,1/6-.1);
			\draw (.1,1/6+.1) -- (-.1,1/6-.1)
			(-.1,1/6+.1) -- (.1,1/6-.1);
			\draw (1/3+.1,1/6+.1) -- (1/3-.1,1/6-.1)
			(1/3-.1,1/6+.1) -- (1/3+.1,1/6-.1);
			\draw (-1/3+.1,-1/6+.1) -- (-1/3-.1,-1/6-.1)
			(-1/3-.1,-1/6+.1) -- (-1/3+.1,-1/6-.1);
			\draw (.1,-1/6+.1) -- (-.1,-1/6-.1)
			(-.1,-1/6+.1) -- (.1,-1/6-.1);
			\draw (1/3+.1,-1/6+.1) -- (1/3-.1,-1/6-.1)
			(1/3-.1,-1/6+.1) -- (1/3+.1,-1/6-.1);
		}
	},
	mass/.style args={#1}{
		node component,
		minimum height = 1.1cm,
		minimum width = 1.5cm,
		path picture={%
			\draw[fill=Background,#1] (-.5,-.5) rectangle (.5,.5);
		},
	},
	mass2/.style args={#1}{
		node component,
		minimum height = 1.1cm,
		minimum width = 1.5cm,
		draw,
		path picture={%
			%			\draw[fill=Background,#1] (path picture bounding box.north west) rectangle (path picture bounding box.south east);
			\node{$ m $};
		}
	},
	inertia/.style={
		component,
		minimum height = 14mm+\pgflinewidth,
		minimum width = 4mm+\pgflinewidth,
		path picture={%
			\draw[fill=white!80!black] (-.2,-.7) rectangle (.2,.7);
		}
	},
	inertia2/.style 2 args={
		mass={#1}{#2},
		path picture={%
			\draw[fill=Background] (-.5,-.5) rectangle (.5,.5);
			\node{$ J $};
		}
	},
	rpossource/.style 2 args={
		component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={#2:#1},
		path picture={%
			\draw[line width = 1mm,Background, shorten > = .5pt, shorten < = .5pt] (-.75,0) -- (.75,0);
			\draw[<<->>,>=stealth, shorten > = .5pt, shorten < = .5pt] (-.75,0) -- (.75,0);
			\node[fill=Background,minimum width = .4cm]{$ \varphi $};
		}
	},
	tpossource/.style 2 args={
		component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={#2:#1},
		path picture={%
			\draw[line width = 1mm,Background, shorten > = .5pt, shorten < = .5pt] (-.75,0) -- (.75,0);
			\draw[<->,>=stealth, shorten > = .5pt, shorten < = .5pt] (-.75,0) -- (.75,0);
			\node[fill=Background,minimum width = .4cm]{$ x $};
		}
	},
	transmissionl1/.style 2 args={
		component,
		yshift=-1cm,
		minimum height = 2.5cm,
		minimum width = 1cm,
		label={#2:#1},pos=1,
		path picture={%
			\draw[fill=Background] (0,.1) arc (90:-90:.1);
			\draw (0,1) -- ++ (0,-2);
			\draw (0,-1) -- ++ (-.25,.125) -- ++ (0, -.25) -- cycle;
			\draw (-.25,-.8) -- ++(0,-.4);
			\fill[pattern=north east lines] (-.25,-.8) rectangle ++(-.15,-.4);
			\draw[fill=Background] (0,1) circle (.1);
			\draw[fill=Background] (0,-1) circle (.1);
		}
	},
	transmissiong1/.style 2 args={
		component,
		yshift=-1cm,
		minimum height = 2.5cm,
		minimum width = 1cm,
		label={#2:#1},
		pos=0,
		path picture={%
			\draw[fill=Background] (0,.1) arc (-270:-90:.1);
			\draw (0,1) -- ++ (0,-2);
			\draw (0,-1) -- ++ (-.25,.125) -- ++ (0, -.25) -- cycle;
			\draw (-.25,-.8) -- ++(0,-.4);
			\fill[pattern=north east lines] (-.25,-.8) rectangle ++(-.15,-.4);
			\draw[fill=Background] (0,1) circle (.1);
			\draw[fill=Background] (0,-1) circle (.1);
		}
	},
	cabledrumr/.style 2 args={
		component,
		yshift=-.5cm,
		minimum height = 2cm,
		minimum width = 1.5cm,
		label={#2:#1},
		pos = 1,
		path picture={%
			\draw[fill=Background] (-.3,.6) rectangle (.3,-.5);
			\draw (-.3,.5) --++ (.6,-.05)
			++(-.6,-.05) --++ (.6,-.05)
			++(-.6,-.05) --++ (.6,-.05)
			++(-.6,-.05) --++ (.6,-.05);
		}
	},
	cabledruml/.style 2 args={
		component,
		yshift=-.5cm,
		minimum height = 2cm,
		minimum width = 1.5cm,
		label={#2:#1},
		pos = 1,
		path picture={%
			\draw[fill=Background] (-.3,.6) rectangle (.3,-.5);
			\draw (.3,.5) --++ (-.6,-.05)
			++(.6,-.05) --++ (-.6,-.05)
			++(.6,-.05) --++ (-.6,-.05)
			++(.6,-.05) --++ (-.6,-.05);
		}
	},
	forcesource/.style 2 args={
		line component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={#2:#1},
		path picture={%
			\draw (-0.2,.15) -- (0.2,0) -- (-0.2,-.15);
		}
	},
	torquesource/.style 2 args={
		component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={#2:#1},
		path picture={%
			\draw (-0.35,.15) -- (0.05,0) -- (-0.35,-.15);
			\draw (-0.05,.15) -- (0.35,0) -- (-0.05,-.15);
		}
	},
	forcesource2/.style args={#1}{
		line component,
		minimum height = 0.35cm,
		minimum width = 1.5cm,
		path picture={%
			\fill[Background] (-7.5mm+0.5\pgflinewidth,-0.6*\pgflinewidth) rectangle (7.5mm-0.5*\pgflinewidth,0.6*\pgflinewidth);
%			\draw[<->,>=stealth, shorten > = 0.5\pgflinewidth, shorten < = 0.5\pgflinewidth] (-.75,0) -- (.75,0);
			\node[minimum width = .4cm,minimum height = .3cm](F){$ F $};
			\begin{scope}[-stealth, shorten > = 0.5\pgflinewidth]
				\draw (F) -- (path picture bounding box.west);
				\draw (F) -- (path picture bounding box.east);
			\end{scope}
		},
		#1
	},
	torquesource2/.style 2 args={
		component,
		minimum height = 1cm,
		minimum width = 1.5cm,
		label={#2:#1},
		path picture={%
			\draw[line width = 1mm,Background, shorten > = .5pt, shorten < = .5pt] (-.75,0) -- (.75,0);
			\draw[<<->>,>=stealth, shorten > = .5pt, shorten < = .5pt] (-.75,0) -- (.75,0);
			\node[fill=Background,minimum width = .4cm]{$ T $};
		}
	},
	centerofmass/.style={
		line width = 1pt,
		minimum size = #1+1pt,
		circle,
		draw,
		path picture={%
			\draw[black,line width=1pt] (0,0) circle (.5*#1-.5pt);
			\fill[Background] (#1,#1) rectangle (-#1,-#1);
			\fill[] (0,0) rectangle (-#1,-#1);
			\fill[] (0,0) rectangle (#1,#1);
		}
	},
}
%    \end{macrocode}
%               \subsection{Additional macros}
%    \begin{macrocode}
\tikzset{
    numbered grid label/.code={
        \tikzset{
            gray,
            font=\tiny,
            inner ysep=0.5pt,
            inner xsep=2.5pt,
        }
        \pgfkeys{
            /pgf/number format/.cd,
                fixed,
                fixed zerofill=true,
                precision=3,
        }
    },
}

\def\numgrid{\@ifnextchar[%
    {\numgrid@i}{\numgrid@i[1]}%
}
\def\numgrid@i[#1]{\@ifnextchar[%
    {\numgrid@ii{#1}}{\numgrid@ii{#1}[0]}%
}
\def\numgrid@ii#1[#2]{\@ifnextchar[%
    {\numgrid@iii{#1}{#2}}{\numgrid@iii{#1}{#2}[0]}
}
\def\numgrid@iii#1#2[#3]#4#5{
    \pgfmathsetmacro\xstep{#1+#2}%
    \pgfmathsetmacro\ystep{#1+#3}%
    \foreach \x in {#2,\xstep,...,#4}{
        \draw[help lines] (\x,#3) -- (\x,#5) foreach \pos/\place in {0/left,1/right}{
            node[numbered grid label,pos=\pos, \place,rotate=90]{\pgfmathprintnumber{\x}}};
    }
    \foreach \y in {#3,\ystep,...,#5}{
        \draw[help lines] (#2,\y) -- (#4,\y) foreach \pos/\place in {0/left,1/right}{
            node[numbered grid label,pos=\pos, \place]{\pgfmathprintnumber{\y}}};
    }
}
\makeatother
%</xbg-iconicdiagrams-code>
%<*xbg-blockdiagrams-code>
\makeatletter
\newdimen\xbg@bd@block@iospacing
\newdimen\xbg@bd@block@height

\newif\ifxbg@bd@block@flip
\newcounter{xbg@sum@elements}

\tikzset{
    sum/.style={
        append after command={
            \pgfextra{
                \setcounter{xbg@sum@elements}{0}%
                \foreach \j in {#1}{\stepcounter{xbg@sum@elements}}
                \pgfmathsetmacro\@noelem{max(4,\thexbg@sum@elements)}
                \def\@plus{+}%
                \def\@min{-}%
                \foreach[count=\i from 0] \@el in {#1}{
                    \edef\ex@el{\@el}
                    \pgfmathsetmacro\@ang{360/\@noelem*\i + 180}%
                    \draw (\tikzlastnode) ++(\@ang:0.25) ++(\@ang+90:0.15)%
                        \ifx\ex@el\@plus%
                                +(-0.5mm,0mm) -- +(0.5mm,0mm)
                                +(0mm,-0.5mm) -- +(0mm,0.5mm)
                        \else
                            \ifx\ex@el\@min%
                                +(-0.5mm,0mm) -- +(0.5mm,0mm)
                            \fi
                        \fi;
                }
            }
        },
        node contents={},
        circle,
        draw,
        minimum size=4mm,
    },
    sum/.default = {+,-},
    signalname/.style={},
}

\tikzset{
    block/.code={
        \xbgset{
            block/.cd,
            #1
        }
        \pgfmathsetlengthmacro{\xbg@bd@block@height}{%
            max(10mm, int(max(\xbg@bd@block@inputs,\xbg@bd@block@outputs) * \xbg@bd@block@iospacing))}
        \xbgset{block/block template}
    },
    signalname/.code={
        \tikzset{
            align=center,
        }
    },
    splitter/.style args ={
        fill,
        inner sep = 0pt,
        minimum size = 1.5mm,
        circle,
    },
}
\xbgset{
    block/.is family,
    block/.cd,
        inputs/.code={
            \pgfmathparse{int(#1)}
            \let\xbg@bd@block@inputs=\pgfmathresult
        },
        inputs=1,
        outputs/.code={
            \pgfmathparse{int(#1)}
            \let\xbg@bd@block@outputs=\pgfmathresult
        },
        outputs=1,
        io spacing/.code=\setlength\xbg@bd@block@iospacing{#1},
        io spacing=5mm,
        flip/.is choice,
        flip/true/.code={\xbg@bd@block@fliptrue\def\xbg@bd@block@flipbool{1}},
        flip/false/.code={\xbg@bd@block@flipfalse\def\xbg@bd@block@flipbool{0}},
        flip/.default=true,
        flip=false,
        block template/.code=\tikzset{
            draw,
            align=center,
            minimum width = 15mm,
            minimum height = \xbg@bd@block@height,
            shape=block,
            text = Iconic Contents,
            prefix after command= {
                \pgfextra{
                    \tikzset{
                        every label/.style={
                            Iconic Label,
                        }
                    }
                }
            },
        },
}
\pgfdeclareshape{block}{
    \inheritsavedanchors[from={rectangle}]
    \savedanchor\centerpoint{%
        \pgf@x=.5\wd\pgfnodeparttextbox%
        \pgf@y=.5\ht\pgfnodeparttextbox%
        \advance\pgf@y by-.5\dp\pgfnodeparttextbox%
    }
    \inheritsavedanchors[from=rectangle]
    \inheritanchorborder[from=rectangle]
    \inheritanchor[from=rectangle]{north}
    \inheritanchor[from=rectangle]{north west}
    \inheritanchor[from=rectangle]{north east}
    \inheritanchor[from=rectangle]{center}
    \inheritanchor[from=rectangle]{text}
    \inheritanchor[from=rectangle]{west}
    \inheritanchor[from=rectangle]{east}
    \inheritanchor[from=rectangle]{mid}
    \inheritanchor[from=rectangle]{mid west}
    \inheritanchor[from=rectangle]{mid east}
    \inheritanchor[from=rectangle]{base}
    \inheritanchor[from=rectangle]{base west}
    \inheritanchor[from=rectangle]{base east}
    \inheritanchor[from=rectangle]{south}
    \inheritanchor[from=rectangle]{south west}
    \inheritanchor[from=rectangle]{south east}
    \savedmacro\blockinputs{%
        \pgfmathparse{int(\xbg@bd@block@inputs)}%
        \let\blockinputs=\pgfmathresult}%
    \savedmacro\blockoutputs{%
        \pgfmathparse{int(\xbg@bd@block@outputs)}%
        \let\blockoutputs=\pgfmathresult}%
    \savedmacro\blockmaxio{%
        \pgfmathparse{int(max(\xbg@bd@block@inputs,\xbg@bd@block@outputs))}%
        \let\blockmaxio=\pgfmathresult}%
    \savedmacro\blockflip{%
        \pgfmathparse{\xbg@bd@block@flipbool}%
        \let\blockflip=\pgfmathresult}%
    \saveddimen\halfwidth{\pgfmathsetlength\pgf@x{%
        \pgfkeysvalueof{/pgf/minimum width}/2}\pgfmathresult}
    \saveddimen\halfheight{\pgfmathsetlength\pgf@x{%
        \pgfkeysvalueof{/pgf/minimum height}/2}\pgfmathresult}
    \saveddimen\iospacing{\pgfmathsetlength\pgf@x{%
        \xbg@bd@block@iospacing}\pgfmathresult}
    \inheritbackgroundpath[from={rectangle}]
    \pgfutil@g@addto@macro\pgf@sh@s@block{%
        \pgfmathloop%
        \ifnum\pgfmathcounter>\blockinputs\relax%
        \else%
            \pgfutil@ifundefined{pgf@anchor@block@input \pgfmathcounter}{%
                \expandafter\xdef\csname pgf@anchor@block@input %
                    \pgfmathcounter\endcsname{\noexpand%
                    \pgf@sh@lib@block@in@anchor{\pgfmathcounter}%
                }%
            }{}
        \repeatpgfmathloop%
        \pgfmathloop%
        \ifnum\pgfmathcounter>\blockoutputs\relax%
        \else%
            \pgfutil@ifundefined{pgf@anchor@block@output \pgfmathcounter}{%
                \expandafter\xdef\csname pgf@anchor@block@output %
                \pgfmathcounter\endcsname{\noexpand%
                    \pgf@sh@lib@block@out@anchor{\pgfmathcounter}%
                }%
            }{}
        \repeatpgfmathloop%
    }%
}

\def\pgf@sh@lib@block@in@anchor#1{%
    \pgf@process{\centerpoint}%
    \pgf@ya=\pgf@y%
    \ifnum\blockflip=0\relax%
        \pgf@process{\southwest}%
    \else%
        \pgf@process{\northeast}%
    \fi%
    \pgfmathsetlength\pgf@y{\pgf@ya + (0.5*(\blockinputs+1)-#1)*\iospacing}
}
\def\pgf@sh@lib@block@out@anchor#1{%
    \pgf@process{\centerpoint}%
    \pgf@ya=\pgf@y%
    \ifnum\blockflip=0\relax%
        \pgf@process{\northeast}%
    \else%
        \pgf@process{\southwest}%
    \fi%
    \pgfmathsetlength\pgf@y{\pgf@ya + (0.5*(\blockoutputs+1)-#1)*\iospacing}
}
\makeatother
%</xbg-blockdiagrams-code>
%    \end{macrocode}
%       \fi
% \Finale
\endinput